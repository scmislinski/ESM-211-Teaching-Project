---
title: "Modeling Out Data"
format: html
editor: visual
---

# library

Use the library enmpa for the tools Use terra for the mapping

```{r}
library(enmpa)
library(terra)
library(tidyverse)
library(here)
library(geodata)
library(predicts)

```

# Cleaning the Data and Linking it to the Bioclim Data

## Getting the Bio Data

This code gets the bioclim data

```{r}
#load bioclim data
bioclim_data <- worldclim_global(var = "bio",
                                    res = 2.5,
                                    path = "Data/")
```

## Loading Our Data

```{r}
#This is the milkweed data
obs_data_mw <- read_csv(here("Data","Milkweed.csv")) |>
  select(gbifID, decimalLatitude, decimalLongitude) |> drop_na()|>
  rename(latitude=decimalLatitude) |> 
  rename(longitude=decimalLongitude)

#This is the monarch data
obs_data_m <- read_csv(here('Data','Monarch.csv')) |>
  select(gbifID, decimalLatitude, decimalLongitude) |> drop_na()|>
  rename(latitude=decimalLatitude) |> 
  rename(longitude=decimalLongitude)

```

## Cleaning Bioclim data and Linking it to the Milkweed Data Set

THIS IS ONLY FOR THE MILKWEED DATA I was thinking that we could deminstrate it for one of the data sets and then have them do it for the onther one.

```{r}
# This bit of code allows us to crop the bioclim data for just the section we have for the milkweed.
max_lat <- ceiling(max(obs_data_mw$latitude))
min_lat <- floor(min(obs_data_mw$latitude))
max_lon <- ceiling(max(obs_data_mw$longitude))
min_lon <- floor(min(obs_data_mw$longitude))
# Store boundaries in a single extent object
geographic_extent <- ext(x = c(min_lon, max_lon, min_lat, max_lat))

# This makes a pretty map for our milkweed data.
world_map <- world(resolution = 3,
                   path = "data/")
# Crop the map to our area of interest
my_map <- crop(x = world_map, y = geographic_extent)
# Plot the base map
plot(my_map,
     axes = TRUE,
     col = "grey95")
# Add the points for individual observations
points(x = obs_data_mw$longitude,
       y = obs_data_mw$latitude,
       col = "darkgreen",
       pch = 20,
       cex = 0.75)


```

# Preparing the Data for Modeling

```{r}
#prepare the data for modeling

sample_extent <- geographic_extent * 1.25
# Crop bioclim data to desired extent
bioclim_data <- crop(x = bioclim_data, y = sample_extent)

# Plot the first of the bioclim variables to check on cropping
plot(bioclim_data[[1]])
```

## Pseudo-absences

This is how we get pseudo absences out of the milkweed data

```{r}
set.seed(1234) #This insures we get the same results every time

# Randomly sample points (same number as our observed points)
background_mw <- spatSample(x = bioclim_data,
                         size = 500, # generate 500 pseudo-absence points
                         values = FALSE, # don't need values
                         na.rm = TRUE, # don't sample from ocean
                         xy = TRUE) # just need coordinates

# Pull out coordinate columns, x (longitude) first, then y (latitude) from
# saguaro data
presence_mw  <- obs_data_mw[, c("longitude", "latitude")]

# Add column indicating presence
presence_mw$pa <- 1

# Convert background data to a data frame
absence_mw <- as.data.frame(background_mw)
# Update column names so they match presence points
colnames(absence_mw) <- c("longitude", "latitude")
# Add column indicating absence
absence_mw$pa <- 0
# Join data into single data frame
all_points_mw <- rbind(presence_mw, absence_mw)


#add the climate data
bioclim_extract_mw <- terra::extract(x = bioclim_data,
                           y = all_points_mw[, c("longitude", "latitude")],
                           ID = FALSE) # No need for an ID column #### for what ever reason, you need to specsify that the extract function is coming from the terra package so the "terra::" portion is absolutely critical

# Add the point and climate datasets together
points_climate_mw <- cbind(all_points_mw, bioclim_extract_mw)

```

## Cleaning and Linking the Monarch Data Sets

will do this later once I know it worked for the milkweed data

```{r}

```

# Running the enmpa Package

```{r}
points_climate_mw <- as.data.frame(points_climate_mw, xy = TRUE)

calibration <- calibration_glm(data = points_climate_mw, dependent = "pa",
                               independent = c("wc2.1_2.5m_bio_1", "wc2.1_2.5m_bio_12"),
                               response_type = "lpq",
                               formula_mode = "intensive", 
                               exclude_bimodal = TRUE, 
                               selection_criterion = "TSS",
                               cv_kfolds = 5, 
                               verbose = FALSE)
calibration
#> enmpa-class `enmpa_calibration`:
#> $selected             : Selected models (N = 2)
#> $summary              : A summary of statistics for all models. 
#> $calibration_results  : Results obtained from cross-validation for all models. 
#> $data                 : Data used for calibration. 
#> $partitioned_data     : k-fold indexes (k = 5)
#> $weights              : Use of weights (FALSE)
 
summary(calibration)
```

## Fitting the Model

```{r}
env_vars <- rast(system.file("extdata", "vars.tif", package = "enmpa"))


points_climate_mw <- as.data.frame(points_climate_mw, xy = TRUE)

fits <- fit_selected(calibration) 

# Prediction for the two selected models and their consensus
preds_E  <- predict_selected(fits, newdata = env_vars, extrapolation_type = "E",
                             consensus = TRUE)
preds_NE <- predict_selected(fits, newdata = env_vars,extrapolation_type = "NE",
                             consensus = TRUE)

# Visualization 
plot(c(preds_E$predictions, preds_NE$predictions),
     main = c("Model ID 31 (Free Extrapolation)",
              "Model ID 31 (No Extrapolation)"),
     mar = c(1, 1, 2, 5))
```
